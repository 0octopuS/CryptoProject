//
//  main.c
//  SM4
//
//  Created by Christine  Lin on 07/01/2022.
//  Copyright Â© 2022 Christine  Lin. All rights reserved.
//

#include <stdio.h>
#include <time.h>
#include "sm4.h"
#include <benchmark/benchmark.h>

unsigned char buf[32*4],buf1[32*4],buf2[32*4];
#define size 256
sm4_key_t key;
unsigned char user_key[16]=
{
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10
};
unsigned char plaintext[128] = {
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
    0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,

};
    unsigned char ciphertext[] = {
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46,
         0x68, 0x1e, 0xdf, 0x34, 0xd2, 0x06, 0x96, 0x5e,
         0x86, 0xb3, 0xe9, 0x4f, 0x53, 0x6e, 0x42, 0x46
    };
    uint32_t rk[32] = {
         0xf12186f9, 0x41662b61, 0x5a6ab19a, 0x7ba92077,
         0x367360f4, 0x776a0c61, 0xb6bb89b3, 0x24763151,
         0xa520307c, 0xb7584dbd, 0xc30753ed, 0x7ee55b57,
         0x6988608c, 0x30d895b7, 0x44ba14af, 0x104495a1,
         0xd120b428, 0x73b55fa3, 0xcc874966, 0x92244439,
         0xe89e641f, 0x98ca015a, 0xc7159060, 0x99e1fd2e,
         0xb79bd80c, 0x1d2115b0, 0x0e228aeb, 0xf1780c81,
         0x428d3654, 0x62293496, 0x01cf72e5, 0x9124a012,
     };





static void sm4_basic_speed(benchmark::State& state) {
    // printf("------  sm4_basic_test: \n ------");
    // test_sm4(sm4_basic_encrypt_block);
    sm4_set_key(user_key,&key);
    size_t blocks = sizeof(plaintext)/SM4_BLOCK_SIZE;
    for (auto _ : state) {
        sm4_basic_encrypt_block(plaintext, buf, &key,blocks);
    }
    //state.counters["Rate"] = benchmark::Counter(sizeof(plaintext)/1e6,);
}

static void sm4_T_speed(benchmark::State& state) {
    // printf("------  sm4_basic_test: \n ------");
    // test_sm4(sm4_T_encrypt_block);
    sm4_set_key(user_key,&key);
    size_t blocks = sizeof(plaintext)/SM4_BLOCK_SIZE;
    for (auto _ : state) {
        sm4_T_encrypt_block(plaintext, buf, &key,blocks);
    }
    //state.counters["Rate"] = benchmark::Counter(sizeof(plaintext)/1e6, benchmark::Counter::kIsRate);
}


static void sm4_avx2_speed(benchmark::State& state) {
    sm4_set_key(user_key,&key);
    size_t blocks = sizeof(plaintext)/SM4_BLOCK_SIZE;
    for (auto _ : state) {
        sm4_avx2_encrypt_block(plaintext, buf, &key,blocks);
    }
    //state.counters["Rate"] = benchmark::Counter(sizeof(plaintext)/1e6, benchmark::Counter::kIsRate);
}


static void sm4_aesni_speed(benchmark::State& state) {
    sm4_set_key(user_key,&key);
    size_t blocks = sizeof(plaintext)/SM4_BLOCK_SIZE;
    for (auto _ : state) {
        sm4_ni_encrypt_block(plaintext, buf, &key,blocks);
    }
    //state.counters["Rate"] = benchmark::Counter(sizeof(plaintext)/1e6, benchmark::Counter::kIsRate);
}

static void sm4_avx2ni_speed(benchmark::State& state) {
    sm4_set_key(user_key,&key);
    size_t blocks = sizeof(plaintext)/SM4_BLOCK_SIZE;
    for (auto _ : state) {
        sm4_avx2ni_encrypt_block(plaintext, buf, &key,blocks);
    }
    //state.counters["Rate"] = benchmark::Counter(sizeof(plaintext)/1e6, benchmark::Counter::kIsRate);
}
BENCHMARK(sm4_basic_speed);
BENCHMARK(sm4_T_speed);
BENCHMARK(sm4_avx2_speed);
BENCHMARK(sm4_aesni_speed);
BENCHMARK(sm4_avx2ni_speed);
BENCHMARK_MAIN();
